gensbi.flow_matching.solver
===========================

.. py:module:: gensbi.flow_matching.solver


Submodules
----------

.. toctree::
   :maxdepth: 1

   /api/gensbi/flow_matching/solver/ode_solver/index
   /api/gensbi/flow_matching/solver/sde_solver/index
   /api/gensbi/flow_matching/solver/solver/index
   /api/gensbi/flow_matching/solver/utils/index


Classes
-------

.. autoapisummary::

   gensbi.flow_matching.solver.NonSingular
   gensbi.flow_matching.solver.ODESolver
   gensbi.flow_matching.solver.Solver
   gensbi.flow_matching.solver.ZeroEnds


Package Contents
----------------

.. py:class:: NonSingular(velocity_model, mu0, sigma0, alpha)

   Bases: :py:obj:`BaseSDESolver`


   
   NonSingular SDE solver.

   From tab 1 of `arXiv:2410.02217 <http://arxiv.org/abs/2410.02217>`_, with change of variable for time: t -> 1-t to match our time notation.















   ..
       !! processed by numpydoc !!

   .. py:method:: get_f_tilde(**kwargs)

      
      Get the function :math:`        ilde{f}` for the velocity model. See arXiv.2410.02217
      Also known as the "drift" term in the SDE context.
















      ..
          !! processed by numpydoc !!


   .. py:method:: get_g_tilde()

      
      Get the function :math:`        ilde{g}` for the velocity model. See arXiv.2410.02217
      Also known as the "diffusion" term in the SDE context.
















      ..
          !! processed by numpydoc !!


   .. py:attribute:: alpha


.. py:class:: ODESolver(velocity_model)

   Bases: :py:obj:`gensbi.flow_matching.solver.solver.Solver`


   
   A class to solve ordinary differential equations (ODEs) using a specified velocity model.

   This class utilizes a velocity field model to solve ODEs over a given time grid using numerical ode solvers.

   :param velocity_model: a velocity field model receiving :math:`(x,t)` and returning :math:`u_t(x)`
   :type velocity_model: Union[ModelWrapper, Callable]

   .. rubric:: Example

   .. code-block:: python

       from gensbi.flow_matching.solver import ODESolver
       from gensbi.utils.model_wrapping import ModelWrapper
       import jax, jax.numpy as jnp
       class DummyModel:
           def __call__(self, x, t, args=None):
               return x + t
       model = ModelWrapper(DummyModel())
       solver = ODESolver(velocity_model=model)
       x_init = jnp.zeros((10, 2))
       time_grid = jnp.linspace(0, 1, 5)
       sol = solver.sample(x_init=x_init, step_size=0.05, time_grid=time_grid)
       print(sol.shape)
       # (5, 10, 2)















   ..
       !! processed by numpydoc !!

   .. py:method:: get_sampler(step_size, method = 'Dopri5', atol = 1e-05, rtol = 1e-05, time_grid = jnp.array([0.0, 1.0]), return_intermediates = False, model_extras = {})

      
      Solve the ODE with the velocity field.

      :param x_init: initial conditions (e.g., source samples :math:`X_0 \sim p`). Shape: [batch_size, ...].
      :type x_init: Tensor
      :param step_size: The step size. Must be None for adaptive step solvers.
      :type step_size: Optional[float]
      :param method: A method supported by torchdiffeq. Defaults to "Euler". Other commonly used solvers are "Dopri5", "midpoint" and "heun3". For a complete list, see torchdiffeq.
      :type method: str
      :param atol: Absolute tolerance, used for adaptive step solvers.
      :type atol: float
      :param rtol: Relative tolerance, used for adaptive step solvers.
      :type rtol: float
      :param time_grid: The process is solved in the interval [min(time_grid, max(time_grid)] and if step_size is None then time discretization is set by the time grid. May specify a descending time_grid to solve in the reverse direction. Defaults to torch.tensor([0.0, 1.0]).
      :type time_grid: Tensor
      :param return_intermediates: If True then return intermediate time steps according to time_grid. Defaults to False.
      :type return_intermediates: bool, optional
      :param \*\*model_extras: Additional input for the model.

      .. rubric:: Example

      .. code-block:: python

          import torch
          from flow_matching.utils import ModelWrapper
          from flow_matching.solver import ODESolver

          class DummyModel(ModelWrapper):
              def __init__(self):
                  super().__init__(None)

              def forward(self, x: torch.Tensor, t: torch.Tensor, **extras) -> torch.Tensor:
                  return torch.ones_like(x) * 3.0 * t**2

          velocity_model = DummyModel()
          solver = ODESolver(velocity_model=velocity_model)
          x_init = torch.tensor([0.0, 0.0])
          step_size = 0.001
          time_grid = torch.tensor([0.0, 1.0])

          result = solver.sample(x_init=x_init, step_size=step_size, time_grid=time_grid)















      ..
          !! processed by numpydoc !!


   .. py:method:: get_unnormalized_logprob(log_p0, step_size = 0.01, method = 'Dopri5', atol = 1e-05, rtol = 1e-05, time_grid=[1.0, 0.0], return_intermediates = False, *, model_extras = {})

      
      Solve for log likelihood given a target sample at :math:`t=0`.

      :param x_1: target sample (e.g., samples :math:`X_1 \sim p_1`).
      :type x_1: Array
      :param log_p0: Log probability function of source distribution.
      :type log_p0: Callable[[Array], Array]
      :param step_size: Step size for fixed-step solvers.
      :type step_size: Optional[float]
      :param method: Integration method to use.
      :type method: str
      :param atol: Absolute tolerance for adaptive solvers.
      :type atol: float
      :param rtol: Relative tolerance for adaptive solvers.
      :type rtol: float
      :param time_grid: Must start at 1.0 and end at 0.0.
      :type time_grid: Array
      :param return_intermediates: Whether to return intermediate steps.
      :type return_intermediates: bool
      :param exact_divergence: Use exact divergence vs Hutchinson estimator.
      :type exact_divergence: bool
      :param \*\*model_extras: Additional model inputs.

      :returns: Samples and log likelihood values.
      :rtype: Union[Tuple[Array, Array], Tuple[Sequence[Array], Array]]















      ..
          !! processed by numpydoc !!


   .. py:method:: sample(x_init, step_size, method = 'Dopri5', atol = 1e-05, rtol = 1e-05, time_grid = jnp.array([0.0, 1.0]), return_intermediates = False, model_extras = {})


   .. py:method:: unnormalized_logprob(x_1, log_p0, step_size = 0.01, method = 'Dopri5', atol = 1e-05, rtol = 1e-05, time_grid=[1.0, 0.0], return_intermediates = False, *, model_extras = {})


   .. py:attribute:: velocity_model


.. py:class:: Solver

   Bases: :py:obj:`abc.ABC`


   
   Abstract base class for solvers.
















   ..
       !! processed by numpydoc !!

   .. py:method:: sample(x_0)
      :abstractmethod:



.. py:class:: ZeroEnds(velocity_model, mu0, sigma0, alpha, eps0 = 0.001)

   Bases: :py:obj:`BaseSDESolver`


   
   ZeroEnds SDE solver.

   From tab 1 of `arXiv:2410.02217 <http://arxiv.org/abs/2410.02217>`_, with change of variable for time: t -> 1-t to match our time notation.















   ..
       !! processed by numpydoc !!

   .. py:method:: get_f_tilde(**kwargs)

      
      Get the function :math:`        ilde{f}` for the velocity model. See arXiv.2410.02217
      Also known as the "drift" term in the SDE context.
















      ..
          !! processed by numpydoc !!


   .. py:method:: get_g_tilde()

      
      Get the function :math:`        ilde{g}` for the velocity model. See arXiv.2410.02217
      Also known as the "diffusion" term in the SDE context.
















      ..
          !! processed by numpydoc !!


   .. py:attribute:: alpha


